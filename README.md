# Design Patterns in C++
- **[Abstract Factory](https://github.com/rhazari/Design-Patterns/tree/master/AbstractFactory)**
A factory of factories; a factory that groups the individual but related/dependent factories together without specifying their concrete classes.
- **[Adapter](https://github.com/rhazari/Design-Patterns/tree/master/Adapter)**
Adapter pattern lets you wrap an otherwise incompatible object in an adapter to make it compatible with another class.
- **[Bridge](https://github.com/rhazari/Design-Patterns/tree/master/Bridge)**
Bridge pattern is about preferring composition over inheritance. Implementation details are pushed from a hierarchy to another object with a separate hierarchy.
- **[Builder](https://github.com/rhazari/Design-Patterns/tree/master/Builder)**
Allows us to avoid constructor pollution. Useful when there could be several flavors of an object. Or when there are a lot of steps involved in creation of an object.
- **[Decorator](https://github.com/rhazari/Design-Patterns/tree/master/Decorator)**
Decorator pattern lets you dynamically change the behavior of an object at run time by wrapping them in an object of a decorator class.
- **[Factory](https://github.com/rhazari/Design-Patterns/tree/master/Factory)**
It provides a way to delegate the instantiation logic to child classes.
- **[Proxy](https://github.com/rhazari/Design-Patterns/tree/master/Proxy)**
Using the proxy pattern, a class represents the functionality of another class.
- **[Singleton](https://github.com/rhazari/Design-Patterns/tree/master/Singleton)**
Ensures that only one object of a particular class is ever created.
- **[Strategy](https://github.com/rhazari/Design-Patterns/tree/master/Strategy)**
Strategy pattern allows you to switch the algorithm or strategy based upon the situation.
